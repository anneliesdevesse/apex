#!/usr/bin/perl

use strict;

return 1;


sub showheader {
print OUTP<<"VERDER";
<?xml version='1.0' encoding='UTF-8'?>
<apex:apex xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.kuleuven.be/exporl/Lab/Apex  apex-schema.xsd"
  xmlns:apex="http://www.kuleuven.be/exporl/Lab/Apex"
  version="1">

  <!-- Generated by apexapi.pl -->

VERDER

}

sub showfooter {
print OUTP<<"VERDER";

</apex:apex>

VERDER

}


sub seekheader {
	my $name = $_[0];
	seek INP, 0, 0;			# beginning of file
	while ($_ = <INP>) {
		if (index($_, $name)!=-1) {
			return 1;
		}
	}
	return 0;
}


sub parsestimuli {
	&seekheader('[stimuli]') or die ("Can't find [stimuli] header");

	my @stimuli;
	my $stimulus;
	my ($path, $line, $filename, $sentence, $label, $button,$dummy);

	while (<INP>) {
		chomp();
		s/\r//;

		if (/^path=(.*)/) {
			$path = $1;
			next;
		}
		next if /^defaultmap/;
		next if /^standard/;
		next if /^defaultstandard/;

		($dummy,$filename) = /^(stimulus|signal)=([^,]+)/;
		last if ($filename eq '');

		($sentence) = /sentence=([^,]+)/;
		($label) = /label=([^,]+)/;
		($button) = /button=([^,]+)/;

		$stimulus = {
			filename	=>	$filename,
			sentence 	=> $sentence,
			label		=> $label,
			button		=> $button
		};

		push (@stimuli, $stimulus);

#		print "filename=$filename, sentence=$sentence\n";
	}

	return $path, @stimuli;
}

# parse standards
sub parsestandards {
	&seekheader('[stimuli]') or die ("Can't find [stimuli] header");

	my @standards;
	my $standard;
	my ($path, $line, $filename, $sentence, $label, $button);
	my ($defaultstandard);

	while (<INP>) {
		chomp();

		next if (/^path=(.*)/);
		next if /^defaultmap/;
		next if /^stimulus/;
		next if /^signal/;

		($filename) = /standard=([^,]+)/;		# also matches defaultstandard
		last if ($filename eq '');

		($sentence) = /sentence=([^,]+)/;
		($label) = /label=([^,]+)/;
		($button) = /button=([^,]+)/;

		$standard = {
			filename	=>	$filename,
			sentence 	=> $sentence,
			label		=> $label,
			button		=> $button
		};

		if (/^defaultstandard=([^,]+)/) {
			$defaultstandard = $1;		# filename
		}

		push (@standards, $standard);

#		print "filename=$filename, sentence=$sentence\n";
	}

	return $defaultstandard, @standards;
}



# return a hash of method parameters
sub parsemethod {
	&seekheader('[method]') or die ("Can't find [method] header");

# set default values
	my %results = (
		start	=>	0,
		skip	=>	0,
		up	=> 1,
		down	=> 1,
		numrevsformean 	=>	10,
		feedback	=>	"no",
		practice	=>	"no",
		highlight	=> 	"yes",
		autopause	=> 	"no",
		haltafter	=> 	"no",
		random		=> 	"yes",
		easierislarger =>	"yes"
);


	my ($line,$key,$value);
	while($line=<INP>) {
		chomp($line);
		$line =~ s/\r//;
		($key,$value) = $line =~ /^(\w+)=(.*)$/;
		last unless ($key);
		chomp($key);
		chomp($value);
		$results{$key} = $value;
	}


	# modify method contents
	my %thash = (	"yes" => "random", "no" => "sequential" );
	$results{random} = $thash{$results{random}};
	return \%results;
}

sub parseshowdevice {
	&seekheader('[device]') or die ("Can't find [device] header");


	print OUTP "<devices>\n";

	my $line = <INP>;
	chomp($line);
	$line =~ s/\r//;

	my $type;
	($type) = ($line =~ /^device=([^,]+)/);

	if ($type eq 'NUCLEUS') {

	} elsif ($type eq 'AUDIO') {
		print OUTP <<"VERDER";
	<device id="dev" xsi:type="apex:wavDeviceType">
        <driver>portaudio</driver>
	<card>default</card>
	<channels>2</channels>
        <gain>0</gain>
        <samplerate>44100</samplerate>
        <buffersize>512</buffersize>

VERDER
	} else {
		print "Error: unknown device in $line\n";
		exit(1);
	}

	print OUTP "	</device>\n";
	print OUTP "</devices>\n\n";


 }

 sub showstimuli {
	 #my @stimuli = @_;
	 my ($stimuli,$standards,$globals) = @_;


 print OUTP<<"VERDER";
	<stimuli>
VERDER


# stimuli #
###########


print OUTP<<"VERDER";
		<fixed_parameters>
			<parameter id="param"/>
VERDER

if ( $$stimuli[0]->{label}) {				# we assume that if the first stimulus has a label, all stimuli will have one
	print OUTP "<parameter id=\"label\"/>";
}

print OUTP<<"VERDER";
		</fixed_parameters>
VERDER


	my $count=0;
	my $device = "dev";		# fixme
	my $stimulus;

	foreach $stimulus (@$stimuli) {
		&showstimulus($stimulus, "stimulus$count", "datablock$count",$count);
		++$count;
}


# standards #
#############

	$count=0;

	foreach $stimulus (@$standards) {
		&showstimulus($stimulus, "standard$count", "standarddatablock$count",$count);


		# show default standard again with a different label
		if ($globals->{defaultstandard} eq $stimulus->{filename}) {
			&showstimulus($stimulus, "defaultstandard", "standarddatablock$count",$count);
		}
		++$count;
	}



	print OUTP "</stimuli>\n\n";

}


sub showstimulus {
	my ($stimulus, $id, $datablock,$count) = @_;

			print OUTP<<"VERDER";
    <stimulus id="$id">
      <description>Autogenerated stimulus</description>
      <datablocks>
        <datablock id="$datablock"/>
      </datablocks>
      <variableParameters/>
VERDER

	print OUTP "<fixedParameters>\n";

	if ( $stimulus->{label}) {
		print OUTP<<"VERDER";
			   <parameter id="label">$stimulus->{label}</parameter>
VERDER
	}

	print OUTP "<parameter id=\"param\">$count</parameter>\n";
	print OUTP "</fixedParameters>\n";


		print OUTP<<"VERDER";
    </stimulus>
VERDER

}

sub showdatablocks {
	my ($globals,$stimuli,$standards) = @_;

	print OUTP<<"VERDER";
	<datablocks>
	<uri_prefix>file:$globals->{'path'}</uri_prefix>
VERDER


	my $count=0;
	my $device = "dev";		# fixme
	my $stimulus;

	foreach $stimulus (@$stimuli) {
		print OUTP<<"VERDER";
			<datablock id="datablock$count">
				<device>$device</device>
			<description>Autogenerated datablock</description>
			<birth>2005-05-19T00:00:00Z</birth>
			<checksum>10</checksum>
			<uri>$stimulus->{filename}</uri>
			</datablock>
VERDER
		++$count;
}


 # standards
	$count=0;
	foreach $stimulus (@$standards) {
		print OUTP<<"VERDER";
			<datablock id="standarddatablock$count">
				<device>$device</device>
			<description>Autogenerated datablock</description>
			<birth>2005-05-19T00:00:00Z</birth>
			<checksum>10</checksum>
			<uri>$stimulus->{filename}</uri>
			</datablock>
VERDER
		++$count;
}


	print OUTP "</datablocks>\n\n";

}


# use tidy to indent file properly
sub cleanup {
	my ($filename) = $_[0];

	system("tidy -q -i -xml -o $filename $filename");

}

sub showreinforcement {
print OUTP<<"VERDER";
  <reinforcement>
      <progressbar>true</progressbar>
      <feedback length="300">true</feedback>
    </reinforcement>
VERDER

}

sub showequalcorrector {
	print OUTP <<"VERDER";
	<corrector xsi:type="apex:isequal"/>

VERDER

}

sub showalternativescorrector {
	my ($method) = @_;


if (!defined($method->{intervals})) {
	die("Can't find number of intervals in parseshowscreen");
}

my $intervals = $method->{intervals};

print OUTP<<"VERDER";
  <corrector xsi:type="apex:alternatives">
    <answers>
VERDER
for (my $i=1; $i<=$intervals; ++$i) {
	print OUTP "<answer number=\"$i\" value=\"button$i\"/>\n";
}

print OUTP<<"VERDER";
     </answers>
  </corrector>
VERDER

}

# convert apex 2 style stepsize string to new format
sub parseshowstepsizes {
	my $s = $_[0];

	print OUTP "<stepsizes>\n";
	print OUTP "<change_after>reversals</change_after>\n";

	my @arr = split(/,/,$s);
	my $begin;
	my $size;
	for (my $i=0; $i<=$#arr; ++$i) {
		($size,$begin) = ($arr[$i] =~ /^(.*)\/(.*)$/);
		print OUTP "<stepsize begin='$begin' size='$size'/>\n";
	}


	print OUTP "</stepsizes>\n";
}


# expects references to stimuli and method parameters
sub showadaptiveprocedure {
	my ($stimuli,$standards,$globals, $method) = @_;



my %thash = ( "yes" => "true", "no" => "false" );
if (exists($method->{largeriseasier}) ) {
	if ( $method->{largeriseasier} eq "yes") {
		$method->{easierislarger} = "no";
	} else {
			$method->{easierislarger} = "yes";
	}
}
$method->{easierislarger} = $thash{$method->{easierislarger}};

print OUTP<<"VERDER";
    <procedure xsi:type="apex:adaptiveProcedureType">
VERDER
print OUTP<<"VERDER";
    <parameters>
      <presentations>1</presentations>
      <skip>$method->{skip}</skip>
      <order>$method->{random}</order>
VERDER

if ( exists( $globals->{defaultstandard}) and defined( $globals->{defaultstandard} ) ) {
	print OUTP "<defaultstandard>defaultstandard</defaultstandard>\n";
}

if ( exists( $method->{intervals})) {
	print OUTP "<choices>$method->{intervals}</choices>\n";
}

print OUTP<<"VERDER";
      <nUp>$method->{up}</nUp>
      <nDown>$method->{down}</nDown>
      <adapt_parameter>$globals->{adaptparam}</adapt_parameter>
      <start_value>$method->{start}</start_value>
      <stop_after>$method->{stop}</stop_after>
      <stop_after_type>reversals</stop_after_type>
      <rev_for_mean>$method->{numrevsformean}</rev_for_mean>
      <larger_is_easier>$method->{easierislarger}</larger_is_easier>
VERDER
&parseshowstepsizes($method->{stepsize});


print OUTP<<"VERDER";
    </parameters>
VERDER

	&showfixedadaptivetrials($stimuli,$standards,$globals);

	print OUTP<<"VERDER";
   </procedure>


VERDER

}

# show trials for an adaptive procedure with fixed parameters (ie: multiple stimuli per trial)
sub showfixedadaptivetrials {
	my ($stimuli,$standards,$globals) = @_;

	print OUTP<<"VERDER";
	<trials>
			<trial id="trial">
				<screen id="screen1" />
VERDER


	my $stimulus;
	my $count;

	for ($count=0; $count<= $#$stimuli; ++$count) {
		print OUTP<<"VERDER";
			<stimulus id="stimulus$count" />
VERDER

	}

# 	if ( $globals->{hasstandard} ) {
# 		&showdefaultstandard($standards,$globals->{defaultstandard});
# 	}

	print OUTP<<"VERDER";
		</trial>
	</trials>

VERDER
}


# sub showdefaultstandard {
# 	my ($standards,$globals) = @_;
# 	print OUTP "<standard id='defaultstandard'/>\n";
# }

sub parseshowbuttonscreen {

# get help text
my $helptext;
if (seekheader('[help]')) {
	my $line = <INP>;
	chomp ($line);
	$line =~ s/\r//;
	$helptext= $line =~ /^task=(.*)$/;
}
# else {
# 	$helptext= ""Type what you hear";
# }


unless (seekheader('[screen]')) {
	die( "Can't find [screen] header\n");
}

# get width and height
my $line=<INP>;
chomp($line);
$line =~ s/\r//;
my ($height,$width,$num);
($width,$height,$num) = $line =~ /^button=(\d+),(\d+),(\d+),(.*)$/;
seekheader('[screen]');

print OUTP<<"VERDER";
 <screens>
VERDER
  &showreinforcement;
  print OUTP<<"VERDER";
    <screen id="screen1" >
VERDER
if ($helptext ne '') {
print OUTP<<"VERDER";
      <gridLayout height="2" width="1" id="main_layout">
		<label x="1" y="1" id="helptext">
			<text>$helptext</text>
		</label>
VERDER
}

print OUTP<<"VERDER";
		<gridLayout height="$height" width="$width" id="button_layout">
VERDER


my ($x, $y, $id);
my @ids;
while ($line=<INP>) {
	chomp($line);
	$line =~ s/\r//;
	($height,$width,$num,$id) = $line =~ /^button=(\d+),(\d+),(\d+),(.*)$/;
	last unless ($num);

	$x=int($num/$width);
	$y=$num%$width+1;

	print OUTP<<"VERDER";
		<button x="$x" y="$y" id="$id">
			<text>$id</text>
		</button>
VERDER

	push @ids, $id;
}


print OUTP<<"VERDER";
	</gridLayout>
VERDER

if ($helptext ne '') {
print OUTP<<"VERDER";
      </gridLayout>
VERDER
}

print OUTP "		<buttongroup id=\"buttongroup\">\n";
foreach $id (@ids) {
        print OUTP "			<button id=\"$id\"/>\n";
}
print OUTP "		</buttongroup>\n";

print OUTP<<"VERDER";
		<default_answer_element>buttongroup</default_answer_element>
    </screen>
  </screens>
VERDER

}

sub showconstantprocedure {
	my ($stimuli,$method) = @_;

print OUTP<<"VERDER";
  <procedure xsi:type="apex:constantProcedureType">
    <parameters>
      <presentations>$method->{repetitions}</presentations>
      <skip>$method->{skip}</skip>
      <order>$method->{random}</order>
     </parameters>
VERDER

	&showtrials($stimuli);

	print OUTP<<"VERDER";
   </procedure>


VERDER

}


sub showtrials {
	my ($stimuli) = @_;

	print OUTP "<trials>\n";

	my $stimulus;
	my $count;

	for ($count=0; $count< scalar @$stimuli; ++$count) {
		print OUTP<<"VERDER";
			<trial id="trial$count">
				<answer>$$stimuli[$count]->{button}</answer>
				<screen id="screen1" />
			<stimulus id="stimulus$count" />
			</trial>
VERDER

	}

	print OUTP "</trials>\n\n";
}


sub showresults {
	my ($script) = @_;

	print OUTP<<"VERDER";
<results>
	<xsltscript>$script</xsltscript>
</results>
VERDER

}
